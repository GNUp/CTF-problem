#!/usr/bin/env python2
'''
Example
To send 'abcd' to cLEMENCy emulator: send c2b(s2c('abcd'))
To recover string from cLEMENCy output: use c2s(b2c(output))
To send 8-bit representation bytes to cLEMENCy emulator: send c2b(input)
To recover 8-bit representation bytes from cLEMENCy output: use b2c(output)
To send integer to cLEMENCy emulator: send c2b(p27(integer))
To recover integer from cLEMENCy output: use u27(b2c(integer))
To search index of pattern in 9-bit represenation bytes: use search(data, pattern)
To overwrite data from offset 0x90 in 9-bit represenation bytes: use edit(data, 0x90, data_to_overwrite_with)

Use cremote to use remote socket.
'''
import binascii
import threading

from pwn import *
from pwnlib import term
from pwnlib.context import context
from pwnlib.timeout import Timeout


# Class for representing 9 bit == 1 byte.
class cByte:
    def __init__(self, data):
        if isinstance(data, cByte):
            data = data.content
        elif (type(data) is not int) \
            or (not data < (0b1 << 9)):
            raise TypeError('Invalid cByte Data')
        self.content = data

    def __str__(self):
        return self.get9Bit()

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.content == other.content
        else:
            return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def clone(self):
        return cByte(self.content)

    def getBit(self, index):
        return (content & (0b1 << index)) != 0

    def get16Bit(self):
        return '{:x}'.format(self.content).rjust(4, '0')

    def get9Bit(self):
        return '{:x}'.format(self.content).rjust(3, '0')

    __copy__ = clone


# Class for representing list of cByte.
class cBytes(list):
    def __init__(self, data=[]):
        to_put = []
        if type(data) is int:
            to_put.append(cByte(data))
        elif isinstance(data, cBytes):
            to_put = data.clone_deep()
        else:
            for item in data:
                if isinstance(item, cByte):
                    to_put.append(item)
                else:
                    to_put.append(cByte(item))

        super(cBytes, self).__init__(iter(to_put))

    def __str__(self):
        return ' '.join([x.get9Bit() for x in self])

    def __add__(self, other):
        return cBytes(list.__add__(self, other))

    def __mul__(self,other):
        return cBytes(list.__mul__(self, other))

    def __getslice__(self,i,j):
        return cBytes(list.__getslice__(self, i, j))

    def __getitem__(self, item):
        result = list.__getitem__(self, item)
        if isinstance(item, slice):
            return cBytes(result)
        else:
            return result

    def clone(self):
        return cBytes(self)

    def clone_deep(self):
        res = [x.clone() for x in self]
        return cBytes(res)

    __copy__ = clone
    __deepcopy__ = clone_deep

    def items(self):
        return self

    # search: searches sublist from list.
    # search(self, pattern) => list of start matching indexes
    def search(self, pattern):
        if not isinstance(pattern, cBytes):
            pattern = cBytes(pattern)

        matches = []
        for i in range(len(self)):
            if self[i] == pattern[0] and self[i:i+len(pattern)] == pattern:
                matches.append(i)
        return matches

    # edit: modifies cBytes starting from offset.
    # edit(self, cBytes_offset, replacing_data) => modified_cBytes
    def edit(self, offset, data):
        if not isinstance(data, cBytes):
            data = cBytes(data)

        length_to_edit = len(data)
        if length_to_edit == 0:
            return self.clone_deep()

        assert offset >= 0
        assert offset + length_to_edit <= len(self)

        return cBytes(self[:offset] + data + self[offset + length_to_edit:])


# bytes_to_cbytes: converts bytes to cBytes.
# bytes_to_cbytes(cLEMENCy_output) => recovered emulator cBytes
def bytes_to_cbytes(to_convert):
    if len(to_convert) < 2:
        return cBytes()
    target_length = len(to_convert) * 8 / 9 * 9
    i = int(binascii.hexlify(to_convert), 16)
    bit_string = '{:b}'.format(i).rjust(len(to_convert) * 8, '0')[:target_length]
    return cBytes([cByte(int(bit_string[x:x+9], 2)) \
            for x in range(0, len(bit_string), 9)])


# cbytes_to_bytes: converts cBytes to bytes.
# cbytes_to_bytes(payload) => cLEMENCy_input
def cbytes_to_bytes(to_convert):
    if len(to_convert) < 1:
        return bytes()
    cBytes = [x.content for x in to_convert]
    bits = ''.join(['{:b}'.format(x).rjust(9, '0') for x in cBytes])
    bits = bits.ljust((len(bits) + 7) / 8 * 8, '0')
    hex_len = len(bits) / 4
    hex_string = '{:x}'.format(int(bits, 2)).rjust(hex_len, '0')
    return binascii.unhexlify(hex_string)


# string_to_cbytes: converts ascii string to cBytes.
# string_to_cbytes(ascii_string) => cLEMENCy_string
def string_to_cbytes(to_convert):
    bit_string = ''.join(['{:b}'.format(ord(x)).rjust(9, '0') for x in to_convert])
    return cBytes([cByte(int(bit_string[x:x+9], 2)) \
                  for x in range(0, len(bit_string), 9)])


# cbytes_to_string: converts cBytes to ascii string.
# cbytes_to_string(cLEMENCy_string) => ascii_string
def cbytes_to_string(to_convert):
    return ''.join([chr(x.content) \
                    if x.content in range(256) \
                    else '\\x{}'.format(x.get9Bit()) for x in to_convert])


# endian_conversion: converts cBytes stream to middle endian and vice versa.
# endian_conversion(cBytes) => endian_converted_cBytes
def endian_conversion(to_convert):
    size = len(to_convert)
    end_type = size % 3
    index_map = [1, 0, 2]

    def bytes_generator(x):
        for i in range(len(x) / 3 * 3):
            yield x[(i / 3 * 3) + index_map[i % 3]]

        if end_type != 0:
            yield x[-1]
        if end_type == 2:
            yield x[-2]

    return cBytes(bytes_generator(to_convert))


# pack_cbytes: packs integer into cBytes.
# pack_cbytes(integer, cBytes_size) => integer_packed_cBytes
def pack_cbytes(to_convert, size):
    limit = 0b1 << 9
    res = []

    for i in range(size):
        res.append(cByte(to_convert % limit))
        to_convert >>= 9

    res.reverse()

    return cBytes(res)


# unpack_cbytes: unpacks integer from cBytes
# unpack_cbytes(cBytes, cBytes_size) => unpacked_integer
def unpack_cbytes(to_convert, size):
    res = 0
    for i in range(size):
        res <<= 9
        res |= to_convert[i].content

    return res


# b2c: same as bytes_to_cbytes().
def b2c(x):
    return bytes_to_cbytes(x)


# c2b: same as cbytes_to_bytes().
def c2b(x):
    return cbytes_to_bytes(x)


# s2c: same as string_to_cbytes().
def s2c(x):
    return string_to_cbytes(x)


# c2s: same as cbytes_to_string().
def c2s(x):
    return cbytes_to_string(x)


# m: same as endian_conversion().
def m(x):
    return endian_conversion(x)


# um: same as endian_conversion().
def um(x):
    return endian_conversion(x)


# search: same as x.search(pattern).
def search(x, pattern):
    return x.search(pattern)


# edit: same as x.edit(offset, data).
def edit(x, offset, data):
    return x.edit(offset, data)


# p9: same as pack_cbytes() with size = 1 and endian conversion.
def p9(x):
    return m(pack_cbytes(x, 1))


# u9: same as unpack_cbytes() with size = 1 and endian conversion.
def u9(x):
    return unpack_cbytes(um(x), 1)


# p18: same as pack_cbytes() with size = 2 and endian conversion.
def p18(x):
    return m(pack_cbytes(x, 2))


# u18: same as unpack_cbytes() with size = 2 and endian conversion.
def u18(x):
    return unpack_cbytes(um(x), 2)


# p27: same as pack_cbytes() with size = 3 and endian conversion.
def p27(x):
    return m(pack_cbytes(x, 3))


# u27: same as unpack_cbytes() with size = 3 and endian conversion.
def u27(x):
    return unpack_cbytes(um(x), 3)


# class to handle remote tube connected to cLEMENCy emulator.
class cremote(remote):
    # recv: receives data from server.
    # recv(size, timeout) => cBytes
    def recv(self, numb=4096, timeout=Timeout.default):
        numb = (numb * 9 + 7) / 8
        recv_data = super(cremote, self).recv(numb, timeout)
        return b2c(recv_data)

    # recv_raw: receives data from server without conversion.
    # recv_raw(size) => bytes
    def recv_raw(self, numb=4096):
        return super(cremote, self).recv_raw(numb)

    # recvuntil: receives data while the given keyword is not detected.
    # recvuntil(keyword) => cBytes
    def recvuntil(self, keyword):
        data = ''
        while True:
            data += self.recv_raw(1)
            if b2c(data).search(s2c(keyword)):
                break

        data = b2c(data)
        return data

    # recvline: same as recvuntil() with keyword = '\n'.
    def recvline(self):
        return self.recvuntil('\n')

    # send: sends string or cBytes to server
    # send(string or cBytes)
    def send(self, data):
        if isinstance(data, cBytes):
            data = c2b(data)
        elif type(data) == str:
            data = c2b(s2c(data))
        super(cremote, self).send(data)

    # send_raw: sends data without conversion
    # send_raw(bytes)
    def send_raw(self, data):
        super(cremote, self).send_raw(data)

    # sendline: sends string or cBytes with newline to server
    # sendline(string or cBytes)
    def sendline(self, data):
        if isinstance(data, cBytes):
            data += s2c('\n')
        elif type(data) == str:
            data += '\n'

        self.send(data)

    # interactive: sends and receives string to / from server interactively.
    # interactive()
    def interactive(self, prompt = term.text.bold_red('$') + ' '):
        log.info('Switching to interactive mode')

        go = threading.Event()
        def recv_thread():
            while not go.isSet():
                try:
                    cur = self.recv(timeout = 0.05)
                    cur = c2s(cur)
                    cur = cur.replace('\r\n', '\n')
                    if cur:
                        sys.stdout.write(cur)
                        sys.stdout.flush()
                except EOFError:
                    log.info('Got EOF while reading in interactive')
                    break

        t = context.Thread(target = recv_thread)
        t.daemon = True
        t.start()

        try:
            while not go.isSet():
                if term.term_mode:
                    data = term.readline.readline(prompt = prompt, float = True)
                else:
                    data = sys.stdin.read(1)

                if data:
                    try:
                        self.send(data)
                    except EOFError:
                        go.set()
                        log.info('Got EOF while sending in interactive')
                else:
                    go.set()

        except KeyboardInterrupt:
            log.info('Interrupted')
            go.set()

        while t.is_alive():
            t.join(timeout = 0.1)
